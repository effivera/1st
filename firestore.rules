/**
 * @file Firebase Security Rules for Effivera Firestore Database
 * @description This ruleset enforces a strict user-ownership model for private user data and a public-read, owner-write model for shared marketplace data. It leverages denormalization to avoid costly `get()` calls and ensures that all write operations are authorized.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile information. Only the user can read/write their own profile.
 * - /equipment/{equipmentId}: Stores equipment listings. Anyone can read, but only the owner can create/update/delete.
 * - /bookings/{bookingId}: Stores booking information. Anyone can read, but only the farmer or owner can create/update/delete.
 * - /produceListings/{listingId}: Stores produce listings. Anyone can read, but only the farmer can create/update/delete.
 * - /carbonCredits/{carbonCreditId}: Stores carbon credit information. Only the associated user can read/write.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data under /users/{userId}.
 * - Listing operations are generally allowed, enabling the marketplace.
 * - All write operations require authentication.
 * - Data validation is relaxed to allow for prototyping and rapid iteration, *except* for ownership fields, which are strictly validated.
 * - No global admin roles are defined. All authorization is based on ownership.
 *
 * Denormalization for Authorization:
 * - The `equipment`, `bookings`, and `produceListings` collections include `ownerId` or `farmerId` to enable ownership-based security rules without requiring additional reads.
 *
 * Structural Segregation:
 * - Private user data and public marketplace listings are stored in separate collections to simplify access control and optimize list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create, update, delete) User with matching UID can modify their own profile.
     * @deny (create, update, delete) User tries to modify another user's profile.
     * @allow (get, list) User with matching UID can read their own profile.
     * @deny (get, list) User tries to read another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner() {
          return resource.data.uid == request.auth.uid;
      }

      function isValidUserCreate(userId) {
        return request.auth.uid == userId && request.resource.data.uid == request.auth.uid;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isValidUserCreate(userId);
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to equipment listings.
     * @path /equipment/{equipmentId}
     * @allow (get, list) Anyone can read equipment listings.
     * @allow (create) Authenticated user can create a listing if they own the equipment.
     * @allow (update, delete) Only the owner of the equipment can modify or delete it.
     * @deny (create) Unauthorized user attempts to create an equipment listing with mismatched ownerId.
     * @deny (update, delete) Unauthorized user attempts to modify or delete equipment they do not own.
     * @principle Public read, owner-only write for marketplace listings.
     */
    match /equipment/{equipmentId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(ownerId) {
            return isSignedIn() && request.auth.uid == ownerId;
        }

        function isExistingOwner() {
            return isSignedIn() && resource.data.ownerId == request.auth.uid;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
        allow update: if isExistingOwner();
        allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to booking information.
     * @path /bookings/{bookingId}
     * @allow (get, list) Anyone can read booking information.
     * @allow (create) Authenticated user can create a booking if they are the farmer or owner.
     * @allow (update, delete) Only the farmer or owner of the booking can modify or delete it.
     * @deny (create) Unauthorized user attempts to create a booking with mismatched farmerId or ownerId.
     * @deny (update, delete) Unauthorized user attempts to modify or delete a booking they are not associated with.
     * @principle Public read, owner-only write for bookings.
     */
    match /bookings/{bookingId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isFarmerOrOwner() {
            return isSignedIn() && (request.resource.data.farmerId == request.auth.uid || request.resource.data.ownerId == request.auth.uid);
        }

        function isExistingFarmerOrOwner() {
            return isSignedIn() && (resource.data.farmerId == request.auth.uid || resource.data.ownerId == request.auth.uid);
        }

        allow get, list: if true;
        allow create: if isSignedIn() && (request.resource.data.farmerId == request.auth.uid || request.resource.data.ownerId == request.auth.uid);
        allow update: if isExistingFarmerOrOwner();
        allow delete: if isExistingFarmerOrOwner();
    }

    /**
     * @description Controls access to produce listings.
     * @path /produceListings/{listingId}
     * @allow (get, list) Anyone can read produce listings.
     * @allow (create) Authenticated user can create a listing if they are the farmer.
     * @allow (update, delete) Only the farmer of the listing can modify or delete it.
     * @deny (create) Unauthorized user attempts to create a produce listing with mismatched farmerId.
     * @deny (update, delete) Unauthorized user attempts to modify or delete produce listing they do not own.
     * @principle Public read, owner-only write for produce listings.
     */
    match /produceListings/{listingId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(farmerId) {
            return isSignedIn() && request.auth.uid == farmerId;
        }

        function isExistingOwner() {
            return isSignedIn() && resource.data.farmerId == request.auth.uid;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.farmerId == request.auth.uid;
        allow update: if isExistingOwner();
        allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to carbon credit information.
     * @path /carbonCredits/{carbonCreditId}
     * @allow (get, list) User with matching UID can read their own carbon credit information.
     * @allow (create, update, delete) User with matching UID can modify their own carbon credit information.
     * @deny (get, list) User tries to read another user's carbon credit information.
     * @deny (create, update, delete) User tries to modify another user's carbon credit information.
     * @principle Enforces document ownership for all operations.
     */
    match /carbonCredits/{carbonCreditId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
            return request.auth != null;
      }

      function isExistingOwner() {
          return isSignedIn() && resource.data.userId == request.auth.uid;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }
  }
}